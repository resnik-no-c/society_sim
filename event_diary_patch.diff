diff --git a/constraint_simulation_v3.py b/constraint_simulation_v3.py
index 9e5f17d..c1b23af 100644
--- a/constraint_simulation_v3.py
+++ b/constraint_simulation_v3.py
@@
-import random, math, itertools, collections, logging, json, pathlib
+import random, math, itertools, collections, logging, json, pathlib, os, csv  # +os & csv for new writers
@@
 class SimulationConfig(NamedTuple):
@@
     social_diffusion: float  # uniform(0.0, 0.10)
     max_rounds: int = DEFAULT_MAX_ROUNDS
+
+    # ─── EVENT / DIARY EXTENSIONS ──────────────────────────────────────
+    impact_lags: Tuple[int, ...] = (4, 8, 16)          # post‑event follow‑ups
+    system_stress_crit: float = 1.0                    # endogenous tipping points
+    trust_crit: float = 0.30
+    coop_crit: float = 0.25
+    critical_sample_rate: float = 0.02                 # % agents in *critical* diary
+    extras_sample_rate: float = 0.05                   # % extras sampled every snapshot
@@
 class EnhancedMassSimulation:
@@
         self.network_topology_log_counter = 0
+
+        # ─── EVENT / DIARY STATE ───────────────────────────────────────
+        self.event_counter      = 0
+        self.last_event_id      = None
+        self.event_round        = {}        # eid → round
+
+        self.event_log          = []        # event snapshots
+        self.diary_critical     = []        # focal agents
+        self.diary_extras       = []        # random crowd sample
+
+        # pick focal agents once
+        self.critical_agent_ids = {
+            p.id for p in random.sample(
+                self.people,
+                max(1, int(len(self.people) * self.params.critical_sample_rate))
+            )
+        }
+
@@
         person = OptimizedPerson(i, self.params)
+        person.sim_ref = self                    # back‑pointer for event hooks
         self.people.append(person)
@@
     # ──────────────────────────────────────────────────────────────────
+    #   EVENT & DIARY HELPERS
+    # ──────────────────────────────────────────────────────────────────
+    def _log_event_snapshot(self, event_id: int, tag: str) -> None:
+        """Group‑level context + choice‑set indicators around an event."""
+        alive = [p for p in self.people if not p.is_dead]
+        self.event_log.append(dict(
+            run_id=self.run_id, round=self.round, event_id=event_id, tag=tag,
+            mean_trust=self._calculate_trust_levels()[0],
+            system_stress=self.system_stress,
+            coop_rate=self.total_mutual_cooperation / max(1, self.total_encounters),
+            pct_coop_strategy=sum(p.strategy == 'cooperative' for p in alive) / len(alive),
+            pct_high_constraint=sum(p.constraint_level > p.constraint_threshold for p in alive) / len(alive),
+            mean_constraint=np.mean([p.constraint_level for p in alive])
+        ))
+
+    def _capture_diary(self, diary_type: str, agent: "OptimizedPerson", event_id: int | None):
+        """Write one diary entry (critical or extras)."""
+        row = dict(
+            run_id=self.run_id,
+            round=self.round,
+            agent_id=agent.id,
+            event_id=event_id,
+            diary_type=diary_type,
+            group_label=agent.group_id,
+            age_rounds=agent.age,
+            strategy_current=agent.strategy,
+            behaviour_last_encounter=getattr(agent, "last_behaviour", None),
+            constraint_level=agent.constraint_level,
+            constraint_threshold=agent.constraint_threshold,
+            forced_switch_flag=int(getattr(agent, "round_switched", -1) == self.round),
+            trust_in_group_mean=getattr(agent, "trust_in_group", 0.5),
+            trust_out_group_mean=getattr(agent, "trust_out_group", 0.5),
+            trust_out_group_penalty=self.params.out_group_penalty,
+            top5_trust_ids=";".join(map(str, agent.get_top5_trust())),
+            cum_payoff=getattr(agent, "cumulative_payoff", 0.0),
+            cum_coop_actions=getattr(agent, "cum_coop", 0),
+            cum_defect_actions=getattr(agent, "cum_defect", 0),
+            last_shock_exposure=self.round - getattr(agent, "last_shock_round", self.round),
+            alive_flag=int(not agent.is_dead),
+        )
+        (self.diary_critical if diary_type == "critical" else self.diary_extras).append(row)
+
+    def _check_threshold_events(self):
+        """Emit an event when stress / trust / cooperation crosses a critical line."""
+        if (
+            self.system_stress >= self.params.system_stress_crit
+            or self._calculate_trust_levels()[0] <= self.params.trust_crit
+            or (
+                self.total_mutual_cooperation / max(1, self.total_encounters)
+                <= self.params.coop_crit
+            )
+        ):
+            self.event_counter += 1
+            eid = self.event_counter
+            self.event_round[eid] = self.round
+            self._log_event_snapshot(eid, "pre")
+            self.last_event_id = eid
+            self._log_event_snapshot(eid, "during")
+
@@
     def _trigger_shock(self, shock_severity: float, total_reduction: float) -> None:
@@
-        self.system_stress += effective_severity
+        self.system_stress += effective_severity
+
+        # ─── Register exogenous‑shock event ────────────────────────────
+        self.event_counter += 1
+        eid = self.event_counter
+        self.event_round[eid] = self.round
+        self._log_event_snapshot(eid, "during")
+        self.last_event_id = eid
@@
 class OptimizedPerson:
@@
     def force_switch(self):
         """Force switch to selfish strategy."""
-        self.strategy = 'selfish'
+        self.strategy = "selfish"
+        self.round_switched = self.sim_ref.round
+
+        # ─── Register forced‑switch event ──────────────────────────────
+        sim = self.sim_ref
+        sim.event_counter += 1
+        eid = sim.event_counter
+        sim.event_round[eid] = sim.round
+        sim._log_event_snapshot(eid, "during")
+        sim.last_event_id = eid
@@
     while self.round < self.params.max_rounds:
+        # Check endogenous tipping‑point at start of loop
+        self._check_threshold_events()
         ...
@@
-        if self.round % 4 == 0:
+        if self.round % 4 == 0:
             self.network_topology_log_counter += 1
+
+            # ─── Extras diary (random crowd) ───────────────────────────
+            alive = [p for p in self.people if not p.is_dead]
+            k = max(1, int(len(alive) * self.params.extras_sample_rate))
+            for p in random.sample(alive, k):
+                self._capture_diary("extras", p, self.last_event_id)
+
+            # ─── Critical‑agent diary snapshot ────────────────────────
+            for p in alive:
+                if p.id in self.critical_agent_ids:
+                    self._capture_diary("critical", p, self.last_event_id)
+
+        # ─── Lagged post‑event snapshots ───────────────────────────────
+        if self.last_event_id is not None:
+            lag = self.round - self.event_round[self.last_event_id]
+            if lag in self.params.impact_lags:
+                self._log_event_snapshot(self.last_event_id, f"post_{lag}")
@@
     def run_simulation(self) -> EnhancedSimulationResults:
@@
-        return self._generate_results(...)
+        results = self._generate_results(
+            self.initial_trait_avg, self.initial_group_populations
+        )
+
+        # ─── Flush new CSVs ────────────────────────────────────────────
+        pd.DataFrame(self.event_log).to_csv(
+            "event_log.csv",
+            mode="a",
+            index=False,
+            header=not os.path.exists("event_log.csv"),
+        )
+        pd.DataFrame(self.diary_critical).to_csv(
+            "agent_diary.csv",
+            mode="a",
+            index=False,
+            header=not os.path.exists("agent_diary.csv"),
+        )
+        pd.DataFrame(self.diary_extras).to_csv(
+            "extras_diary.csv",
+            mode="a",
+            index=False,
+            header=not os.path.exists("extras_diary.csv"),
+        )
+
+        return results
